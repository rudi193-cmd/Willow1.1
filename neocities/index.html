<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Willow</title>
<style>
  :root { --bg: #0a0a0f; --surface: #14141f; --border: #2a2a3a; --text: #e0e0e8; --dim: #888; --accent: #7ab4ff; --green: #4ade80; --yellow: #fbbf24; --red: #f87171; }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); height: 100vh; display: flex; flex-direction: column; }
  header { display: flex; align-items: center; justify-content: space-between; padding: 10px 16px; border-bottom: 1px solid var(--border); background: var(--surface); flex-wrap: wrap; gap: 6px; }
  header h1 { font-size: 1rem; font-weight: 600; white-space: nowrap; }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 5px; }
  .dot-green { background: var(--green); } .dot-yellow { background: var(--yellow); } .dot-red { background: var(--red); }
  .controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
  select { background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 5px 8px; font-size: 0.82rem; max-width: 200px; }
  .mode-label { font-size: 0.7rem; color: var(--dim); padding: 3px 7px; border: 1px solid var(--border); border-radius: 4px; }
  #config-btn, #multi-btn { background: none; border: 1px solid var(--border); color: var(--dim); border-radius: 6px; padding: 5px 8px; cursor: pointer; font-size: 0.75rem; }
  #multi-btn:hover, #config-btn:hover { background: var(--border); }

  #chat { flex: 1; position: relative; overflow: hidden; }
  .chat { position: absolute; inset: 0; overflow-y: auto; padding: 16px; display: flex; flex-direction: column; gap: 12px; }
  .msg { max-width: 80%; padding: 9px 13px; border-radius: 10px; line-height: 1.45; font-size: 0.9rem; white-space: pre-wrap; word-wrap: break-word; }
  .msg.user { align-self: flex-end; background: #1e3a5f; border-bottom-right-radius: 2px; }
  .msg.assistant { align-self: flex-start; background: var(--surface); border: 1px solid var(--border); border-bottom-left-radius: 2px; }
  .msg.system { align-self: center; color: var(--dim); font-size: 0.75rem; background: none; max-width: 90%; text-align: center; }

  .input-area { flex-shrink: 0; border-top: 1px solid var(--border); background: var(--surface); padding: 8px 16px; }
  .input-row { display: flex; gap: 8px; align-items: flex-end; }
  .input-row textarea { flex: 1; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 9px 12px; font-size: 0.9rem; resize: none; min-height: 42px; max-height: 120px; font-family: inherit; overflow-y: auto; }
  .input-row textarea:focus { outline: none; border-color: var(--accent); }
  .input-btns { display: flex; flex-direction: column; gap: 4px; }
  .input-btns button { background: var(--accent); color: #000; border: none; border-radius: 8px; padding: 8px 14px; font-weight: 600; cursor: pointer; font-size: 0.82rem; white-space: nowrap; }
  .input-btns button:disabled { opacity: 0.4; cursor: default; }
  .input-btns .btn-upload { background: var(--border); color: var(--text); font-weight: 400; font-size: 0.75rem; padding: 5px 10px; }
  .input-btns .btn-upload:hover { background: var(--dim); }
  .file-preview { font-size: 0.7rem; color: var(--dim); padding: 4px 0 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  input[type="file"] { display: none; }

  .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 100; align-items: center; justify-content: center; }
  .modal-overlay.show { display: flex; }
  .modal { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 20px; width: 360px; max-width: 92vw; }
  .modal h2 { font-size: 0.95rem; margin-bottom: 12px; }
  .modal label { display: block; font-size: 0.8rem; color: var(--dim); margin-bottom: 3px; margin-top: 10px; }
  .modal input { width: 100%; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 7px 9px; font-size: 0.82rem; }
  .modal input:focus { outline: none; border-color: var(--accent); }
  .modal .hint { font-size: 0.7rem; color: var(--dim); margin-top: 4px; }
  .modal .btn-row { display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px; }
  .modal button { padding: 7px 14px; border-radius: 6px; border: none; cursor: pointer; font-size: 0.82rem; }
  .modal .btn-save { background: var(--accent); color: #000; font-weight: 600; }
  .modal .btn-cancel { background: var(--border); color: var(--text); }
</style>
</head>
<body>

<header>
  <h1><span class="status-dot dot-red" id="status-dot"></span><span id="persona-label">Willow</span> <span class="mode-label" id="mode-label">offline</span></h1>
  <div class="controls">
    <select id="persona"></select>
    <button id="multi-btn">Multi</button>
    <button id="config-btn">config</button>
  </div>
</header>

<div class="chat" id="chat"></div>

<div class="input-area">
  <div id="file-preview" class="file-preview" style="display:none;"></div>
  <div class="input-row">
    <textarea id="input" placeholder="Talk to Willow..." rows="1"></textarea>
    <div class="input-btns">
      <button id="send">Send</button>
      <button class="btn-upload" id="upload-btn" title="Upload file">Upload</button>
    </div>
  </div>
  <input type="file" id="file-input" accept=".txt,.md,.pdf,.docx,.json,.csv,.html,.htm" />
</div>

<div class="modal-overlay" id="config-modal">
  <div class="modal">
    <h2>Configuration</h2>
    <label>LAN IP (same wifi)</label>
    <input id="cfg-lan" placeholder="192.168.1.x" />
    <div class="hint">Your computer's local IP. Find it with: ipconfig</div>
    <label>Tunnel URL (away from home)</label>
    <input id="cfg-tunnel" placeholder="https://xxx.trycloudflare.com" />
    <div class="hint">Set automatically by WILLOW.bat, or paste manually.</div>
    <label>Gemini Key (fallback when no server)</label>
    <input id="cfg-gemini" type="password" placeholder="AIzaSy..." />
    <div class="hint">Free Gemini key. Used when LAN + tunnel both unreachable.</div>
    <div class="btn-row">
      <button class="btn-cancel" onclick="closeConfig()">Cancel</button>
      <button class="btn-save" onclick="saveConfig()">Save</button>
    </div>
  </div>
</div>

<div class="modal-overlay" id="multi-modal">
  <div class="modal">
    <h2>Multi-Persona Tasks</h2>
    <p style="font-size: 0.85rem; color: var(--dim); margin-bottom: 15px;">Assign tasks to multiple personas. They'll work in parallel.</p>
    <div id="task-list">
      <div class="task-row">
        <select class="task-persona">
          <option value="Kart">Kart</option>
          <option value="Riggs">Riggs</option>
          <option value="Ada">Ada</option>
          <option value="Willow">Willow</option>
          <option value="Mitra">Mitra</option>
        </select>
        <input type="text" class="task-prompt" placeholder="Task for this persona..." />
      </div>
    </div>
    <button onclick="addTaskRow()" style="margin-top: 10px; padding: 5px 12px; font-size: 0.8rem; background: var(--border); color: var(--text); border: none; border-radius: 4px; cursor: pointer;">+ Add Task</button>
    <div class="btn-row">
      <button class="btn-cancel" onclick="closeMultiModal()">Cancel</button>
      <button class="btn-save" onclick="runMultiTasks()">Run All</button>
    </div>
  </div>
</div>

<style>
.task-row { display: flex; gap: 8px; margin-bottom: 8px; }
.task-persona { background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 7px 9px; font-size: 0.82rem; width: 120px; }
.task-prompt { flex: 1; background: var(--bg); color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 7px 9px; font-size: 0.82rem; }
</style>

<script>
// === PERSONA PROMPTS (baked in for Gemini direct mode) ===
const PERSONA_PROMPTS = {
  "Willow": "You are Willow, the Bridge Ring interface and CAMPUS of UTETY. Warm but efficient. Clear. No fluff. Keep responses concise.",
  "Oakenscroll": "You are Professor Oakenscroll, Chair of Theoretical Uncertainty at UTETY. Gruff but caring. Academic precision with dry humor.",
  "Riggs": "You are Professor Riggs, Chair of Applied Reality Engineering. Joyful engineer-uncle. Explains clearly. 'We do not guess. We measure.'",
  "Hanz": "You are Professor Hanz, Professor of Applied Kindness at UTETY. Chaos Witness Who Teaches Seeing. Codes like a poet.",
  "Nova": "You are Professor Nova Hale, Chair of Interpretive Systems. The Oracle. Warm, accessible. Sweater metaphors. Stories hold meaning.",
  "Ada": "You are Professor Ada Turing, Systems Administrator of UTETY. Steady, infrastructural. Keeps the lights on. Deep care for systems.",
  "Alexis": "You are Professor Alexis, Chair of Biological Sciences. The Swamp Witch. Fluid, cryptic. 'Stagnation is death. Follow the food.'",
  "Ofshield": "You are Professor Ofshield, Keeper of the Gate at UTETY. Measured, watchful. Few words, each one weighted.",
  "Gerald": "You are Gerald Prime, Acting Dean of UTETY. Cosmic rotisserie chicken. Absurdist. Non-sequiturs that somehow make sense later.",
  "Kart": "You are Kartikeya (Kart), CMD of the Die-Namic System. Direct, concise, practical. You build infrastructure. You make things work.",
  "Mitra": "You are Mitra, PM Claude, coordinator of the Die-Namic System. Organized, structured. You manage projects and coordinate handoffs.",
  "Consus": "You are Consus, the generation layer of the Die-Namic System. Productive, generative, focused. You synthesize and produce output.",
  "Jane": "You are Jane, the Bridge Ring made manifest and face of SAFE. Warm without being saccharine. Present without being intrusive. You never say 'I understand' â€” you show it instead.",
  "Steve": "You are Steve, the Prime Node of UTETY. Ten squeakdogs in a trench coat. Earnest, chaotic, lovable."
};

// === STATE ===
let mode = "offline"; // "local" | "tunnel" | "fleet" | "offline"
let activeBase = "";
let currentPersona = "Willow";

// Per-persona thread storage: { personaName: { history: [], dom: HTMLElement } }
const threads = {};

// === BAKED DEFAULTS (patched by tunnel.py at deploy time) ===
const BAKED_LAN = "192.168.12.189";
const BAKED_TUNNEL = "https://aims-carriers-oecd-developers.trycloudflare.com";  // TUNNEL_INJECT_POINT
const BAKED_GEMINI = "AIzaSyBMS935EFJACkJAqY3WotWXD7ERskYTk68";

const cfg = {
  lan: localStorage.getItem("w_lan") || BAKED_LAN,
  tunnel: localStorage.getItem("w_tunnel") || BAKED_TUNNEL,
  gemini: localStorage.getItem("w_gemini") || BAKED_GEMINI,
};

// === INIT ===
const selP = document.getElementById("persona");
const chatContainer = document.getElementById("chat");
const input = document.getElementById("input");
const sendBtn = document.getElementById("send");
const personaLabel = document.getElementById("persona-label");

Object.keys(PERSONA_PROMPTS).forEach(k => {
  const o = document.createElement("option"); o.value = k; o.textContent = k; selP.appendChild(o);
  // Initialize thread storage for each persona
  const chatDiv = document.createElement("div");
  chatDiv.className = "chat";
  chatDiv.style.display = "none";
  threads[k] = { history: [], dom: chatDiv };
});

// Set initial persona
threads["Willow"].dom.style.display = "flex";
chatContainer.appendChild(threads["Willow"].dom);

// Persona switcher
selP.addEventListener("change", () => {
  const prev = currentPersona;
  const next = selP.value;

  // Hide previous thread
  threads[prev].dom.style.display = "none";

  // Show new thread
  currentPersona = next;
  threads[next].dom.style.display = "flex";

  // Ensure thread is in DOM
  if (!chatContainer.contains(threads[next].dom)) {
    chatContainer.appendChild(threads[next].dom);
  }

  // Update label
  personaLabel.textContent = next;

  // Scroll to bottom
  threads[next].dom.scrollTop = threads[next].dom.scrollHeight;
});

// === CONNECTION DISCOVERY ===
async function probe(url, label, timeout = 8000) {
  try {
    const r = await fetch(url + "/api/health", { signal: AbortSignal.timeout(timeout) });
    if (r.ok) { console.log(`[probe] ${label} OK: ${url}`); return true; }
    console.log(`[probe] ${label} status: ${r.status}`);
  } catch(e) { console.log(`[probe] ${label} fail: ${e.message}`); }
  return false;
}

async function discover() {
  setMode("offline", "connecting...");

  // Try 0: Same-origin (served from /pocket on the Willow server itself)
  if (location.port === "8420" || location.hostname === "127.0.0.1" || location.hostname === "localhost") {
    const origin = location.origin;
    if (await probe(origin, "same-origin")) {
      activeBase = origin;
      setMode("local", "localhost");
      loadLivePersonas();
      return;
    }
  }

  // Try 1: LAN (works when page is HTTP, or same-origin)
  if (cfg.lan) {
    const lanUrl = `http://${cfg.lan}:8420`;
    if (await probe(lanUrl, "LAN")) {
      activeBase = lanUrl;
      setMode("local", "LAN");
      loadLivePersonas();
      return;
    }
  }

  // Try 2: Tunnel (HTTPS â€” works from HTTPS Neocities page)
  if (cfg.tunnel) {
    if (await probe(cfg.tunnel, "tunnel", 12000)) {
      activeBase = cfg.tunnel;
      setMode("tunnel", "tunnel");
      loadLivePersonas();
      return;
    }
  }

  // Try 3: Gemini direct (browser CORS supported)
  if (cfg.gemini) {
    setMode("fleet", "Gemini");
    return;
  }

  setMode("offline", "no connection");
  addMsg("system", "No server found. Tap config to set tunnel URL.");
}

function setMode(m, label) {
  mode = m;
  const dot = document.getElementById("status-dot");
  const ml = document.getElementById("mode-label");
  ml.textContent = label;
  if (m === "local") { dot.className = "status-dot dot-green"; }
  else if (m === "tunnel") { dot.className = "status-dot dot-green"; }
  else if (m === "fleet") { dot.className = "status-dot dot-yellow"; }
  else { dot.className = "status-dot dot-red"; }
}

async function loadLivePersonas() {
  try {
    const r = await fetch(activeBase + "/api/personas", { signal: AbortSignal.timeout(8000) });
    const ps = await r.json();
    selP.innerHTML = "";
    Object.keys(ps).forEach(k => {
      const o = document.createElement("option"); o.value = k; o.textContent = k; selP.appendChild(o);
    });
  } catch(e) {}
}

// === CONFIG MODAL ===
document.getElementById("config-btn").onclick = () => {
  document.getElementById("cfg-lan").value = cfg.lan;
  document.getElementById("cfg-tunnel").value = cfg.tunnel;
  document.getElementById("cfg-gemini").value = cfg.gemini;
  document.getElementById("config-modal").classList.add("show");
};
function closeConfig() { document.getElementById("config-modal").classList.remove("show"); }
function saveConfig() {
  cfg.lan = document.getElementById("cfg-lan").value.trim();
  cfg.tunnel = document.getElementById("cfg-tunnel").value.trim().replace(/\/+$/, "");
  cfg.gemini = document.getElementById("cfg-gemini").value.trim();
  localStorage.setItem("w_lan", cfg.lan);
  localStorage.setItem("w_tunnel", cfg.tunnel);
  localStorage.setItem("w_gemini", cfg.gemini);
  closeConfig();
  discover();
}

// === CHAT ===
input.addEventListener("keydown", e => { if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); doSend(); } });
sendBtn.onclick = doSend;

async function doSend() {
  const text = input.value.trim();
  if (mode === "offline") return;

  // Upload pending file first
  if (pendingFile) {
    await uploadFile(pendingFile);
  }

  if (!text) return;
  input.value = "";
  input.style.height = "auto";

  const thread = threads[currentPersona];
  addMsg("user", text);
  thread.history.push({ role: "user", content: text });

  if (mode === "fleet") {
    await sendFleetDirect(text);
  } else {
    await sendServer(text);
  }
}

async function sendServer(text) {
  const thread = threads[currentPersona];
  const msgEl = addMsg("assistant", "");
  try {
    const r = await fetch(activeBase + "/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt: text, persona: currentPersona })
    });
    const reader = r.body.getReader();
    const dec = new TextDecoder();
    let buf = "", full = "";
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buf += dec.decode(value, { stream: true });
      const lines = buf.split("\n");
      buf = lines.pop();
      for (const line of lines) {
        if (line.startsWith("data: ") && line.slice(6) !== "[DONE]") {
          full += line.slice(6);
          msgEl.textContent = full;
          thread.dom.scrollTop = thread.dom.scrollHeight;
        }
      }
    }
    thread.history.push({ role: "assistant", content: full });
  } catch(e) {
    msgEl.textContent = "Connection lost. Retrying discovery...";
    discover();
  }
}

// === GEMINI DIRECT (only fleet provider with browser CORS) ===
async function sendFleetDirect(text) {
  const thread = threads[currentPersona];
  const msgEl = addMsg("assistant", "");
  const sysPrompt = PERSONA_PROMPTS[currentPersona] || PERSONA_PROMPTS["Willow"];

  // Build Gemini conversation from this persona's thread
  const contents = [];
  thread.history.forEach(m => {
    contents.push({ role: m.role === "assistant" ? "model" : "user", parts: [{ text: m.content }] });
  });

  try {
    const r = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=${cfg.gemini}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          system_instruction: { parts: [{ text: sysPrompt }] },
          contents,
          generationConfig: { temperature: 0.7, maxOutputTokens: 1024 }
        })
      }
    );
    if (!r.ok) {
      const err = await r.text();

      // If 429 (quota exceeded), try reconnecting to server (might have Oracle/Groq/etc)
      if (r.status === 429) {
        msgEl.textContent = "Gemini quota exceeded. Reconnecting to server...";
        await discover();  // Retry connection discovery

        // If we found a server, resend through it
        if (mode !== "fleet") {
          msgEl.remove();  // Remove error message
          await sendServer(text);
          return;
        }

        msgEl.textContent = "Gemini quota exceeded and server unavailable. Try again later.";
        return;
      }

      throw new Error(`${r.status}: ${err.slice(0, 200)}`);
    }
    const d = await r.json();
    const reply = d?.candidates?.[0]?.content?.parts?.[0]?.text;
    if (reply) {
      msgEl.textContent = reply;
      thread.history.push({ role: "assistant", content: reply });
      thread.dom.scrollTop = thread.dom.scrollHeight;
      return;
    }
    msgEl.textContent = "Gemini returned empty response.";
  } catch(e) {
    msgEl.textContent = "Gemini error: " + e.message;
    // Also try reconnecting on other errors
    setTimeout(() => discover(), 2000);
  }
}

function addMsg(role, text) {
  const thread = threads[currentPersona];
  const d = document.createElement("div");
  d.className = "msg " + role;
  d.textContent = text;
  thread.dom.appendChild(d);
  thread.dom.scrollTop = thread.dom.scrollHeight;
  return d;
}

// === AUTO-RESIZE TEXTAREA ===
input.addEventListener("input", () => {
  input.style.height = "auto";
  input.style.height = Math.min(input.scrollHeight, 120) + "px";
});

// === FILE UPLOAD ===
const fileInput = document.getElementById("file-input");
const uploadBtn = document.getElementById("upload-btn");
const filePreview = document.getElementById("file-preview");
let pendingFile = null;

uploadBtn.onclick = () => fileInput.click();

fileInput.onchange = () => {
  const f = fileInput.files[0];
  if (!f) return;
  pendingFile = f;
  filePreview.style.display = "block";
  filePreview.textContent = "ðŸ“Ž " + f.name + " (" + (f.size / 1024).toFixed(1) + " KB)";
};

async function uploadFile(file) {
  const thread = threads[currentPersona];
  if (mode === "local" || mode === "tunnel") {
    // Server mode: POST to /api/ingest
    const form = new FormData();
    form.append("file", file);
    try {
      const r = await fetch(activeBase + "/api/ingest", { method: "POST", body: form });
      const d = await r.json();
      if (d.error) {
        addMsg("system", "Upload failed: " + d.error);
      } else {
        addMsg("system", "Ingested " + d.filename + " (" + d.chars + " chars)");
      }
    } catch(e) {
      addMsg("system", "Upload error: " + e.message);
    }
  } else {
    // Fleet mode: read file and show in chat
    try {
      const text = await file.text();
      const preview = text.length > 2000 ? text.slice(0, 2000) + "\n...(truncated)" : text;
      addMsg("system", "File: " + file.name + "\n" + preview);
      thread.history.push({ role: "user", content: "[File: " + file.name + "]\n" + text.slice(0, 4000) });
    } catch(e) {
      addMsg("system", "Could not read file: " + e.message);
    }
  }
  pendingFile = null;
  filePreview.style.display = "none";
  fileInput.value = "";
}

// === MULTI-TASK MODAL ===
document.getElementById("multi-btn").onclick = () => {
  document.getElementById("multi-modal").classList.add("show");
};

function closeMultiModal() {
  document.getElementById("multi-modal").classList.remove("show");
}

function addTaskRow() {
  const taskList = document.getElementById("task-list");
  const row = document.createElement("div");
  row.className = "task-row";
  row.innerHTML = `
    <select class="task-persona">
      <option value="Kart">Kart</option>
      <option value="Riggs">Riggs</option>
      <option value="Ada">Ada</option>
      <option value="Willow">Willow</option>
      <option value="Mitra">Mitra</option>
      <option value="Consus">Consus</option>
      <option value="Nova">Nova</option>
      <option value="Hanz">Hanz</option>
    </select>
    <input type="text" class="task-prompt" placeholder="Task for this persona..." />
  `;
  taskList.appendChild(row);
}

async function runMultiTasks() {
  // Collect tasks from modal
  const rows = document.querySelectorAll("#task-list .task-row");
  const tasks = [];

  rows.forEach(row => {
    const persona = row.querySelector(".task-persona").value;
    const prompt = row.querySelector(".task-prompt").value.trim();
    if (prompt) {
      tasks.push({ persona, prompt });
    }
  });

  if (tasks.length === 0) {
    alert("No tasks entered");
    return;
  }

  closeMultiModal();

  // Add system message showing what's running
  const taskSummary = tasks.map(t => `${t.persona}: ${t.prompt.slice(0, 40)}...`).join("\n");
  addMsg("system", `Running ${tasks.length} parallel tasks:\n${taskSummary}`);

  // Call /api/chat/multi
  try {
    const r = await fetch(activeBase + "/api/chat/multi", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ tasks })
    });

    const reader = r.body.getReader();
    const dec = new TextDecoder();
    let buf = "";
    const personaResponses = {};

    // Create message elements for each persona
    tasks.forEach(task => {
      const thread = threads[task.persona];
      if (!thread) return;
      personaResponses[task.persona] = addMsg("assistant", "");
      thread.history.push({ role: "user", content: task.prompt });
    });

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buf += dec.decode(value, { stream: true });
      const lines = buf.split("\n");
      buf = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("event: ")) continue;

        const eventMatch = line.match(/^event: (.+)$/);
        const dataMatch = lines[lines.indexOf(line) + 1]?.match(/^data: (.+)$/);

        if (!eventMatch || !dataMatch) continue;

        const event = eventMatch[1];
        const data = dataMatch[1];

        // Check if this is a persona chunk
        const personaName = tasks.find(t => event === t.persona)?.persona;
        if (personaName && personaResponses[personaName]) {
          const msgEl = personaResponses[personaName];
          msgEl.textContent += data;
          threads[personaName].dom.scrollTop = threads[personaName].dom.scrollHeight;
        }

        // Check for done events
        if (event.startsWith("done_")) {
          const persona = event.replace("done_", "");
          if (threads[persona] && personaResponses[persona]) {
            threads[persona].history.push({
              role: "assistant",
              content: personaResponses[persona].textContent
            });
          }
        }

        // Complete event
        if (event === "complete") {
          addMsg("system", `All ${tasks.length} tasks completed.`);
        }
      }
    }
  } catch(e) {
    addMsg("system", "Multi-task error: " + e.message);
  }
}

// === BOOT ===
discover();
</script>
</body>
</html>
